<?php
/**
 * BotServiceApi
 * PHP version 5
 *
 * @category Class
 * @package  VoximplantKitIM
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Voximplant Kit Messaging API Documentation
 *
 * <h1>Basic description</h1>  <p>HTTP API is available via the <u>https://kit-im-{{region}}.voximplant.com/<b>{method}</b></u> endpoint. To send events you need to use jwt token. You can get jwt token via login method using an api token created on api tokens page. You need to pass api token as access_token.</p>  <h1>Authentication</h1>   <p>The parameters that are needed to be sent for generate jwt token are as follows:</p> <ul>   <li><strong>access_token</strong></li>   <li><strong>domain</strong></li> </ul>
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.24
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace VoximplantKitIM\Resources;

use GuzzleHttp\Psr7\MultipartStream;
use VoximplantKitIM\VoximplantKitIMClient;
use VoximplantKitIM\VoximplantKitIMRequest;
use VoximplantKitIM\ObjectSerializer;

/**
 * BotServiceApi Class Doc Comment
 *
 * @category Class
 * @package  VoximplantKitIM
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BotServiceApi
{
    /**
     * @var VoximplantKitIMClient
     */
    protected $client;

    /**
     * @param VoximplantKitIMClient $client
     */
    public function __construct(VoximplantKitIMClient $client) {
        $this->client = $client;
    }

    /**
     * Operation login
     *
     * @param  string $channel_uuid channel_uuid (required)
     *
     * @throws \VoximplantKitIM\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \VoximplantKitIM\Model\MessagingLoginResponseType
     */
    public function login($channel_uuid)
    {
        $request = $this->loginRequest($channel_uuid);
        list($response) = $this->client->sync($request);
        return $response;
    }

    /**
     * Operation loginAsync
     *
     * 
     *
     * @param  string $channel_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loginAsync($channel_uuid)
    {
        $request = $this->loginRequest($channel_uuid);
        return $this->client->async($request)->then(
               function ($response) {
               	return $response[0];
               }
        );
    }

    /**
     * Create request for operation 'login'
     *
     * @param  string $channel_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return VoximplantKitIMRequest
     */
    protected function loginRequest($channel_uuid)
    {
        // verify the required parameter 'channel_uuid' is set
        if ($channel_uuid === null || (is_array($channel_uuid) && count($channel_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_uuid when calling login'
            );
        }

        $resourcePath = '/api/v3/botService/login';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($channel_uuid !== null) {
            $formParams['channel_uuid'] = ObjectSerializer::toFormValue($channel_uuid);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->client->getHeaderSelector()->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->client->getHeaderSelector()->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->client->getConfig()->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->client->getConfig()->getApiKeyWithPrefix('domain');
        if ($apiKey !== null) {
            $queryParams['domain'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->client->getConfig()->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->client->getConfig()->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $request = new VoximplantKitIMRequest(
            'POST',
            $this->client->getConfig()->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
        $request->setResponseType('\VoximplantKitIM\Model\MessagingLoginResponseType');
        return $request;
    }
    /**
     * Operation refreshToken
     *
     * @param  string $refresh_token refresh_token (required)
     *
     * @throws \VoximplantKitIM\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \VoximplantKitIM\Model\MessagingLoginResponseType
     */
    public function refreshToken($refresh_token)
    {
        $request = $this->refreshTokenRequest($refresh_token);
        list($response) = $this->client->sync($request);
        return $response;
    }

    /**
     * Operation refreshTokenAsync
     *
     * 
     *
     * @param  string $refresh_token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshTokenAsync($refresh_token)
    {
        $request = $this->refreshTokenRequest($refresh_token);
        return $this->client->async($request)->then(
               function ($response) {
               	return $response[0];
               }
        );
    }

    /**
     * Create request for operation 'refreshToken'
     *
     * @param  string $refresh_token (required)
     *
     * @throws \InvalidArgumentException
     * @return VoximplantKitIMRequest
     */
    protected function refreshTokenRequest($refresh_token)
    {
        // verify the required parameter 'refresh_token' is set
        if ($refresh_token === null || (is_array($refresh_token) && count($refresh_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $refresh_token when calling refreshToken'
            );
        }

        $resourcePath = '/api/v3/botService/refreshToken';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($refresh_token !== null) {
            $formParams['refresh_token'] = ObjectSerializer::toFormValue($refresh_token);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->client->getHeaderSelector()->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->client->getHeaderSelector()->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->client->getConfig()->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->client->getConfig()->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $request = new VoximplantKitIMRequest(
            'POST',
            $this->client->getConfig()->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
        $request->setResponseType('\VoximplantKitIM\Model\MessagingLoginResponseType');
        return $request;
    }
    /**
     * Operation sendEvent
     *
     * @param  \VoximplantKitIM\Model\MessagingIncomingEventType $body body (required)
     * @param  string $channel_uuid Your channel uuid. Set in query path. See an example. (required)
     *
     * @throws \VoximplantKitIM\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \VoximplantKitIM\Model\InlineResponse200
     */
    public function sendEvent($body, $channel_uuid)
    {
        $request = $this->sendEventRequest($body, $channel_uuid);
        list($response) = $this->client->sync($request);
        return $response;
    }

    /**
     * Operation sendEventAsync
     *
     * 
     *
     * @param  \VoximplantKitIM\Model\MessagingIncomingEventType $body (required)
     * @param  string $channel_uuid Your channel uuid. Set in query path. See an example. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendEventAsync($body, $channel_uuid)
    {
        $request = $this->sendEventRequest($body, $channel_uuid);
        return $this->client->async($request)->then(
               function ($response) {
               	return $response[0];
               }
        );
    }

    /**
     * Create request for operation 'sendEvent'
     *
     * @param  \VoximplantKitIM\Model\MessagingIncomingEventType $body (required)
     * @param  string $channel_uuid Your channel uuid. Set in query path. See an example. (required)
     *
     * @throws \InvalidArgumentException
     * @return VoximplantKitIMRequest
     */
    protected function sendEventRequest($body, $channel_uuid)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling sendEvent'
            );
        }
        // verify the required parameter 'channel_uuid' is set
        if ($channel_uuid === null || (is_array($channel_uuid) && count($channel_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_uuid when calling sendEvent'
            );
        }

        $resourcePath = '/{channel_uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_uuid' . '}',
                ObjectSerializer::toPathValue($channel_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->client->getHeaderSelector()->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->client->getHeaderSelector()->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer token
        if ($this->client->getConfig()->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->client->getConfig()->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->client->getConfig()->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->client->getConfig()->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        $request = new VoximplantKitIMRequest(
            'POST',
            $this->client->getConfig()->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
        $request->setResponseType('\VoximplantKitIM\Model\InlineResponse200');
        return $request;
    }
}
